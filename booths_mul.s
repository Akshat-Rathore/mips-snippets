##### Data Segment ###########
.data
number_prompt1:
   .asciiz "Enter first number: "
number_prompt2:
   .asciiz "Enter second number: "
err_mssg:
   .asciiz "\n The entered numbers must be less than 2^15 and more than -2^15. Aborting..."

ans:
    .asciiz "\n Product of the two numbers are:"

newline:
   .asciiz "\n"

##### Code Segment ###########
   .text
   .globl main
main:

# Prompt for entering the first number
   la $a0, number_prompt1
   li $v0, 4
   syscall

   # Scan the first entered number (stored in $v0)
   li $v0, 5
   syscall

   # Store the first number in t0
   add $t0, $v0, $zero

   # Prompt for entering the second number
   la $a0, number_prompt2
   li $v0, 4
   syscall

   # Scan the second entered number (stored in $v0)
   li $v0, 5
   syscall

   # Store the second number in t1
   add $t1, $v0, $zero

   

   addi $t2, $zero, 1   
   sll $t2, $t2, 15 # store 2^15
   sub $t3, $zero, $t2 # store -2^15
   addi $t2, $t2, 1
   addi $t3, $t3, -1
   # sanity check for 1st value
   slt $t4, $t0, $t2 # if more than 2^15, generate error
   beq $t4, $zero, error
   slt $t4, $t3, $t0 # if less than -2^15,  generate error
   beq $t4, $zero, error
   # sanity check for 2nd value
   slt $t4, $t1, $t2
   beq $t4, $zero, error
   slt $t4, $t3, $t1
   beq $t4, $zero, error

   la $a0, ans
   li $v0, 4
   syscall

   add $s0, $zero, $t0 # store 1st value in s0
   add $s1, $zero, $t1 # store 2nd value in s1
   addi $s2, $zero, 0 # initialize s2 to store count
   add $t5, $zero, $s0
   ble $s0, $zero, Neg_n 
   add $a0, $zero, $s0 # check maximum number of bits in s0
   jal find_n
con1:
   add $s2, $v0, $zero 
   add $t5, $zero, $s1
   ble $s1, $zero, Neg_n1
   add $a0, $zero, $s1 # check maximum number of bits in s1
   jal find_n
con2:
   add $t1, $v0, $zero 
   slt $t0, $s2, $t1
   bne $t0, $zero, put
   addi $s2, $s2, 1
   j booth

booth:
   add $a0, $zero, $s0 # store M
   add $a1, $zero, $s1 # store Q
   add $a2, $zero, $s2 # store count
   jal multiply_booth
   add $s4, $zero, $v0 # store multiplication
   add $a0, $v0, $zero
   li $v0, 1 # print answer
   syscall
   la $a0, newline
   li $v0, 4
   syscall

   j exit
   


find_n:
   addi $t0, $zero, 0
   addi $t1, $zero, 1
   add $t2, $a0, $zero
   slt $t3, $t2, $t1
   beq $t3, $zero, L1
   j exit_find_n

L1:
   addi $t0, $t0, 1
   sll $t1, $t1, 1
   slt $t3, $t2, $t1
   bne $t3, $zero, exit_find_n
   j L1

exit_find_n:
   add $v0, $t0, $zero
   jr $ra

put:
   add $s2, $zero, $t1
   addi $s2, $s2, 1
   j booth

Neg_n:
   nor $t5, $t5, $zero
   addi $t5, $t5, 1
   add $a0, $zero, $t5 # check maximum number of bits in s1
   jal find_n
   j con1

Neg_n1:
   nor $t5, $t5, $zero
   addi $t5, $t5, 1
   add $a0, $zero, $t5 # check maximum number of bits in s1
   jal find_n
   j con2


multiply_booth:
   add $t0, $zero, $zero # A
   add $t1, $zero, $zero # Q-1
   add $s0, $zero, $a0 # M
   add $s1, $zero, $a1 # Q
   add $s2, $zero, $a2 # count
   add $s3, $zero, $a2 # constant copy of count
   j booth_l


booth_l:

   andi $t4, $s1, 1   # last bit of Q stored
   

   sll $t4, $t4, 1  # shift bit to left to append Q-1 later
   or $t4, $t4, $t1  # Q-1 appended
   
   addi $t5, $zero, 2 
   beq $t4, $t5, minus # if 10, do A=A-M
   addi $t5, $zero, 1 
   beq $t5, $t4, plus  # else if 01, do A=A+M
   j next_booth_iteration # else continue 


plus:
   add $t0, $t0, $s0 # A=A+M
   j next_booth_iteration

minus:
   sub $t0, $t0, $s0 # A=A-M
   j next_booth_iteration

next_booth_iteration:   # handles arithmetic right shift of AQ(Q-1)
   andi $t4, $t0, 1  # extract last bit of A to construct new Q
   sra $t0, $t0, 1   # A generated by arithmetic right shift by 1
   andi $t5, $s1, 1 # extract last bit of Q to later store in Q-1
   sra $s1, $s1, 1   # arithmetic right shift of Q by 1
   addi $s4, $zero, 1  
   add $t6, $zero, $s3  # load value of n to change n-th bit(MSB) of Q with last bit of A
   addi $t6, $t6, -1   
   sllv $t4, $t4, $t6  # let b = last bit of A, generates b000...(n-1) times
   sllv $s4, $s4, $t6 
   addi $s4, $s4, -1 # generates 111...(n-1) times
   and $s4, $s4, $s1 # collects last n-1 bits of Q 
   or $s1, $t4, $s4 # Q generated as b followed by (n-1) bits of Q
   add $t1, $zero, $t5 # Q-1 generated as last bit of Q
   addi $s2, $s2, -1  # count = count -1
   beq $s2, $zero, exit_booth # if count is 0, exit
   j booth_l # else jump to booth_l

exit_booth: # creates AQ and returns 
   
   add $v0, $zero, $t0 # store A in v0
   sllv $v0, $v0, $s3 # shift A left by n-bits since size of Q does not changes
   or $v0, $v0, $s1 # add Q to last and empty n-bits
   
   jr $ra # return


error:
   li $v0, 4
   la $a0, err_mssg
   syscall

   li $v0, 10
   syscall

exit:
   li $v0, 10
   syscall